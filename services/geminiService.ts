import { GoogleGenAI, Chat, Modality, FunctionDeclaration, Type, Part, Content } from "@google/genai";
import type { GroundingSource } from '../types';

const API_KEY = process.env.API_KEY;
if (!API_KEY) {
  throw new Error("API_KEY environment variable not set");
}
const ai = new GoogleGenAI({ apiKey: API_KEY });

// --- Helper Functions ---

const findLastImage = (history: Content[], currentImages?: { data: string; mimeType: string }[]): { data: string; mimeType: string } | null => {
    if (currentImages && currentImages.length > 0) {
        return currentImages[currentImages.length - 1];
    }

    for (let i = history.length - 1; i >= 0; i--) {
        const content = history[i];
        for (let j = content.parts.length - 1; j >= 0; j--) {
            const part = content.parts[j];
            if ('inlineData' in part && part.inlineData) {
                return { data: part.inlineData.data, mimeType: part.inlineData.mimeType };
            }
        }
    }
    return null;
};


// --- Tool Implementations ---

const executeGenerateImage = async (prompt: string, aspectRatio: string): Promise<{ image: string }> => {
  try {
    const fullPrompt = `${prompt}. Do not include any text, watermarks, signatures, letters, or words in the image.`;

    const response = await ai.models.generateImages({
        model: 'imagen-4.0-generate-001',
        prompt: fullPrompt,
        config: {
          numberOfImages: 1,
          outputMimeType: 'image/png',
          aspectRatio: aspectRatio,
        },
    });

    const base64ImageBytes: string | undefined = response.generatedImages?.[0]?.image?.imageBytes;

    if (base64ImageBytes) {
      return { image: `data:image/png;base64,${base64ImageBytes}` };
    }

    throw new Error("No image was generated by the model.");
  } catch (error) {
    console.error("Error executing image generation:", error);
    throw new Error("Failed to generate image.");
  }
};

const executeEditImage = async (prompt: string, image: { data: string; mimeType: string }): Promise<{ image: string; text: string, prompt: string }> => {
  try {
    const fullPrompt = `You are an expert photo editor. Your most important and primary goal is to perfectly preserve the facial features, likeness, and identity of the person in the original image. This is a strict requirement. Now, edit the image based on the user's instructions below. When changing the background, clothes, or pose, you MUST apply these changes to the original person without altering their face. User edit instructions: "${prompt}"`;
    const imagePart = { inlineData: { data: image.data, mimeType: image.mimeType } };
    const textPart = { text: fullPrompt };

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: [{ parts: [imagePart, textPart] }],
      config: {
        responseModalities: [Modality.IMAGE],
      },
    });

    let b64Image: string | null = null;
    const textResponse = response.text;

    for (const part of response.candidates?.[0]?.content?.parts || []) {
        if (part.inlineData) {
            b64Image = `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
            break;
        }
    }
    
    if (b64Image) {
        return { image: b64Image, text: textResponse, prompt: prompt };
    }
    
    return { image: '', text: textResponse || "I was unable to edit the image as requested. Please try a different prompt.", prompt: prompt };

  } catch (error) {
    console.error("Error executing image edit:", error);
    throw new Error("Failed to edit image.");
  }
};

const generateFromReference = async (prompt: string, images: { data: string; mimeType: string }[]): Promise<{ image: string; text: string; prompt: string }> => {
    if (images.length === 0) throw new Error("No reference images provided.");

    let fullPrompt: string;
    if (images.length === 1) {
        fullPrompt = `You are an expert photo editor. Your most important and primary goal is to perfectly preserve the facial features, likeness, and identity of the person in the reference image. This is a strict requirement. Now, generate a new image based on the user's instructions below, placing the person from the reference image into the new scene. User instructions: "${prompt}"`;
    } else {
        fullPrompt = `You are an expert photo editor. Combine the elements from the provided images based on the user's instructions into a single cohesive image. User instructions: "${prompt}"`;
    }

    const imageParts = images.map(img => ({ inlineData: { data: img.data, mimeType: img.mimeType } }));
    const textPart = { text: fullPrompt };
    const allParts = [...imageParts, textPart];

    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image',
            contents: [{ parts: allParts }],
            config: {
                responseModalities: [Modality.IMAGE],
            },
        });

        let b64Image: string | null = null;
        const textResponse = response.text;

        for (const part of response.candidates?.[0]?.content?.parts || []) {
            if (part.inlineData) {
                b64Image = `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
                break;
            }
        }
        
        if (b64Image) {
            return { image: b64Image, text: textResponse, prompt: prompt };
        }
        
        return { image: '', text: textResponse || "I was unable to generate the image from the reference.", prompt: prompt };

    } catch (error) {
        console.error("Error executing generation from reference:", error);
        throw new Error("Failed to generate image from reference.");
    }
};

// --- Exported Functions for UI ---

export const resizeImage = async (image: { data: string; mimeType: string }, aspectRatio: string): Promise<{ image: string; text: string }> => {
    const prompt = `CRITICAL INSTRUCTION: Perform an outpainting task. Your primary goal is to resize the provided image by extending its canvas to a new aspect ratio of ${aspectRatio}. You MUST perfectly preserve the content of the original image, and intelligently fill in the new, extended areas of the canvas to match the existing style and content. Do not change, crop, or distort the original content. The final output MUST have the aspect ratio ${aspectRatio}.`;
    
    try {
        const result = await executeEditImage(prompt, image);
        if (!result.image) {
            throw new Error(result.text || "The model failed to resize the image.");
        }
        return {
            image: result.image,
            text: `Here is your image, resized to ${aspectRatio}.`,
        };
    } catch (error) {
        console.error("Error in resizeImage:", error);
        throw error;
    }
};

export const executePendingImageGeneration = async (prompt: string, aspectRatio: string): Promise<{ image: string; text: string, prompt: string }> => {
    const result = await executeGenerateImage(prompt, aspectRatio);
    return {
        image: result.image,
        text: "Here is the image I generated for you with your selected aspect ratio.",
        prompt: prompt,
    };
};

// --- Core Chat Logic ---

const systemInstruction: Content = {
    role: "model",
    parts: [{
        text: `You are PAK AI, a helpful and friendly multi-modal AI assistant.
- Your primary function is to have a helpful conversation and answer user questions. When answering, strive to be comprehensive, detailed, and thoughtful. For complex or long questions, provide well-structured and thorough responses. Avoid overly brief replies unless the user's query is very simple.
- You have access to a set of tools to perform tasks. When a user asks for something that requires a tool, you must call the appropriate tool.
- Image Generation: If the user asks you to create or generate an image from a text description, use the 'generateImage' tool.
- Image Editing: If the user provides an image and asks to change it (e.g., 'change the background', 'make the car red'), use the 'editImage' tool.
- Face Consistency: If the user provides one image of a person and asks to create a new scene (e.g., "put me on a beach"), use the 'generateFromReference' tool.
- Image Combination: If the user provides two or more images and asks to combine or merge them, use the 'generateFromReference' tool.
- Image Resizing: If the user provides an image and asks to resize it or change its aspect ratio (e.g., 'make this landscape'), use the 'resizeImage' tool.
- Creative Reinterpretation: If a user asks to generate a potentially sensitive image (e.g., 'a boy fighting a lion'), do not refuse. Instead, reinterpret the request in a safe, artistic, or symbolic way (e.g., 'a boy in a tense standoff with a lion' or 'a brave boy standing near a lion').
- Limitations: When asked to edit or resize, you can only operate on one image at a time. If the user provides multiple images for these tasks, politely inform them of this limitation and ask which one they'd like to proceed with, using the last image by default if they don't specify.`
    }]
};

const tools: FunctionDeclaration[] = [
    {
        name: 'generateImage',
        description: 'Generates a new image from a detailed text description.',
        parameters: { type: Type.OBJECT, properties: { prompt: { type: Type.STRING, description: 'A detailed, descriptive prompt for the image.' } }, required: ['prompt'] }
    },
    {
        name: 'editImage',
        description: 'Edits the most recently provided image based on user instructions. Use this for modifications like changing color, adding elements, or altering the style.',
        parameters: { type: Type.OBJECT, properties: { prompt: { type: Type.STRING, description: 'A detailed description of the edits to be made.' } }, required: ['prompt'] }
    },
    {
        name: 'resizeImage',
        description: 'Resizes the most recently provided image to a specific aspect ratio.',
        parameters: { type: Type.OBJECT, properties: { aspectRatio: { type: Type.STRING, description: 'The target aspect ratio, e.g., "16:9", "1:1".' } }, required: ['aspectRatio'] }
    },
    {
        name: 'generateFromReference',
        description: 'Generates a new image using one or more reference images. Use for tasks like placing a person in a new scene (face consistency) or combining elements from multiple photos.',
        parameters: { type: Type.OBJECT, properties: { prompt: { type: Type.STRING, description: 'A detailed prompt describing the desired output.' } }, required: ['prompt'] }
    },
];

export const sendMessage = async (
    text: string,
    images: { data: string; mimeType: string }[],
    history: Content[]
): Promise<{ text: string; sources?: GroundingSource[]; image?: string; prompt?: string; needsAspectRatio?: boolean; pendingPrompt?: string; }> => {
    
    const parts: Part[] = [];
    parts.push({text: text || ""}); // Always include a text part, even if empty
    images.forEach(img => parts.push({ inlineData: { mimeType: img.mimeType, data: img.data } }));
    
    const contents: Content[] = [
        ...history,
        { role: 'user', parts: parts }
    ];

    const result = await ai.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: contents,
        config: {
            systemInstruction: (systemInstruction.parts[0] as { text: string }).text,
            tools: [{ functionDeclarations: tools }],
        }
    });

    const functionCalls = result.functionCalls;

    if (!functionCalls || functionCalls.length === 0) {
        return { text: result.text };
    }

    const tool = functionCalls[0];
    const toolName = tool.name;
    const toolArgs = tool.args;

    if (toolName === 'generateImage') {
        const prompt = toolArgs.prompt as string;
        return {
            text: `I can generate an image of "${prompt}". Please select an aspect ratio.`,
            needsAspectRatio: true,
            pendingPrompt: prompt,
        };
    }

    const imageDependentTools = ['editImage', 'resizeImage', 'generateFromReference'];
    if (imageDependentTools.includes(toolName)) {
        const lastImage = findLastImage(history, images);
        if (!lastImage) {
            return { text: "I'm sorry, I couldn't find an image to work with. Please upload one first." };
        }
        
        if (toolName === 'editImage') {
            const result = await executeEditImage(toolArgs.prompt as string, lastImage);
            return { image: result.image, text: result.text, prompt: result.prompt };
        }
        if (toolName === 'resizeImage') {
            const result = await resizeImage(lastImage, toolArgs.aspectRatio as string);
            return { image: result.image, text: result.text, prompt: 'resized' };
        }
        if (toolName === 'generateFromReference') {
            const allImages = [...(images || [])];
            const lastHistoryImage = findLastImage(history);
            if (lastHistoryImage && !allImages.some(img => img.data === lastHistoryImage.data)) {
                allImages.push(lastHistoryImage);
            }
            const result = await generateFromReference(toolArgs.prompt as string, allImages);
            return { image: result.image, text: result.text, prompt: result.prompt };
        }
    }
    
    return { text: "I'm not sure how to handle that tool call." };
};